<?php namespace Hampel\LogDigest\Test;

use Hampel\LogDigest\Option\ServerError;
use Hampel\LogDigest\Option\TimeZone;
use Hampel\LogDigest\Repository\Log;
use Hampel\LogDigest\Service\LogSender\ServerError as ServerErrorService;

class DigestTest extends AbstractTest
{
	public function run()
	{
		$email = $this->data['email'];
		$validator = $this->app->validator('Email');
		if (!$validator->isValid($email, $error))
		{
			$this->errorMessage(\XF::phrase('logdigest_invalid_email_address'));
			return false;
		}

		$generate = $this->getCheckbox('generate');

		if ($generate)
		{
			// create a test exception so we have log data to return
			\XF::logException(new \Exception("This is a test exception generated by the LogDigest addon"));
		}

		$logRepo = $this->getLogRepo();
		$logs = $logRepo->getLogs('XF:ErrorLog', 'error_id', 0);

		$count = 0;
		$sent = false;

		if ($logs)
		{
			$count = $logs->count();

			/** @var ServerErrorService $sender */
			$sender = \XF::service('Hampel\LogDigest:LogSender\ServerError', $logs, TimeZone::get());
			$params = $sender->filterLogData(ServerError::deduplicate(), ServerError::limit());

			if (!empty($params))
			{
				$sent = $sender->send($email, 'server_error', $params);
			}
		}

		if ($count == 0)
		{
			$this->errorMessage(\XF::phrase('logdigest_test_no_logs_found'));
			return false;
		}
		elseif (!$sent)
		{
			$this->errorMessage(\XF::phrase('logdigest_test_returned_false'));
			return false;
		}
		else
		{
			$this->successMessage(\XF::phrase('logdigest_test_successfully_sent', ['count' => $count, 'email' => $email]));
			return true;
		}
	}

	/**
	 * @return Log
	 */
	protected function getLogRepo()
	{
		return $this->app->repository('Hampel\LogDigest:Log');
	}
}
